\documentclass{article}

\usepackage[utf8]{inputenc}

\title{A gas-efficient superlight Bitcoin client in Solidity}
\begin{document}

  \maketitle

  \begin{abstract}
    Place abstract here
  \end{abstract}

  \pagebreak

  \section{Introduction}

  \subsection{Motivation}

  Digital coins are peer-to-peer currencies based on applied
  cryptography for the validation of transactions. Most of them are
  based on blockchain(ref), a form of decentralized database. In this
  database, a public ledger is deployed which is stored and updated by
  thousands of users in absence of supervision from public authorities.

  In 2008, Bitcoin(ref), the first ever successful decentralized digital
  coin, was invented by an unknown person or group of people using the
  name Satoshi Nakamoto. A year after, the bitcoin network started,
  quickly followed by several other digital coins, which in the
  cryptocurrency folklore are known as altcoins. Usually, altcoins are
  based on innovative features previously missing from the
  cryptocurrency market, and they are either accepted or rejected by the
  community. Popular altcoins are Ethereum(ref), which is the first to
  provide smart contracts, Ripple(ref) which provides real-time payment
  settlements and Litecoin(ref) which enables near-zero cost payments.

  Over the last decade, cryptocurrencies gained attention from the
  public as an increased number of users accept and trust decentralized
  transactions. Specifically, in 2017, the popularity of
  cryptocurrencies rapidly grew, resulting in massive capitalisation and
  creation of tokens. During this period, some of the issues that
  blockchain technology faces were displayed. One of these issues is
  blockchain interoperability, the property of distinct blockchains to
  interact efficiently with each other. Despite its great importance,
  this field has not been addressed until recently. To date,
  cryptocurrencies are lacking a commonly accepted protocol that enables
  distributed interoperability. Such a protocol would be very useful to
  blockchain technology, since it would allow users to variously utilize
  features of different blockchains. For example, one can store their
  funds in Bitcoins, and convert them to Ether to make a payment,
  benefiting from lower transaction fees and quicker transactions.

  A crosschain protocol would enable two main operations
  \begin{itemize}
  \item
    Crosschain trading: An entity with deposits in blockchain A, makes a
    payment to an entity at blockchain B.
  \item
    Crosschain fund transfer: Entity transfers owning funds from
    blockchain A to blockchain B. After this operation, the funds no
    longer exist at blockchain A. The entity can return any portion of
    the original amount to the blockchain of origin.
  \end{itemize}

  Currently, this operation is only available to the users via third
  party applications, such as multi-currency wallets. This treatment
  certainly opposes the nature of blockchain, which is a decentralized
  construction. This motivated us to create a solution that enables
  cheap, trust-less crosschain operations.

  \subsection{Previous Work}

  In this paper, we focus on recent research in the area of crosschains.
  In particular, we make use of the cryptographic primitive
  Non-Interactive Proofs of Proof of Work (NIPoPoWs)(ref), which enables
  the compression of a chain to its poly-logarothmic size. NIPoPoWs is
  the main building block of our solution in order to make the
  occurrence of an event of blockchain A provably known to blockchain B.

  We are based on previous work done by Giorgos Christoglou et al.(ref),
  which was the first ever implementation of crosschain events
  verification. The work of Giorgos et al. focuses on verifying Bitcoin
  events from the Ethereum blockchain. In order to provide this
  functionality, a NIPoPoW verifier was developed in Solidity(ref), one
  of the programming languages of Ethereum blockchain. This solution,
  however, is impossible to be applied in a real blockchain due to
  extensive gas usage and severe security issues.

  \subsection{Our contributions}

  A series of keen observations, the application of gas-efficient
  practices and the utilization of modern Solidity features led us to
  the design of a new verifier architecture. This allowed us to repair
  previous vulnerabilities and enable crosschain operations by providing
  a secure, superlight Bitcoin client that can be deployed on the real
  blockchain.

  Our contribution is the creation of a Bitcoin client in Solidity that
  verifies events across blockchains while meeting the following
  criteria:
  \begin{itemize}
  \item
    Security: Is secure against any adversarial attack.
  \item
    Trustless: Does not have dependencies at any third-party
    applications.
  \item
    Applicability: Is applicable to the real blockchain. That is, data
    derived from the full-sized Bitcoin blockchain are successfully
    accepted and processed by the client without exceeding the build-in
    constraints of the Ethereum blockchain (i.e. block gas limit, call
    data limit etc).
  \item
    Cheap: Is cheaper than the current state of the art technologies.
    This would make trustless crosschain transactions more popular and
    affordable.
  \end{itemize}

  \section{Background}

  Relevant technologies

  \subsection{Primitives}

  Describe primitives

  \subsection{Bitcoin}

  Describe Bitcoin blockchain

  \subsection{Ethereum}

  Describe Ethereum blockchain

  \subsubsection{Solidity}

  Describe the use of solidity language

  \subsubsection{Smark contracts}

  Describe the use of smart contracts

  \subsubsection{Ethereum Virtual Machine}

  The Ethereum Virtual Machine (EVM) is a sandboxed virtual stack
  embedded within each full Ethereum node, responsible for executing
  contract bytecode. Contracts are typically written in higher level
  languages, like Solidity, then compiled to EVM bytecode.

  This means that the machine code is completely isolated from the
  network, filesystem or any processes of the host computer. Every node
  in the Ethereum network runs an EVM instance which allows them to
  agree on executing the same instructions. The EVM is Turing complete,
  which refers to a system capable of performing any logical step of a
  computational function. JavaScript, the programming language which
  powers the worldwide web, widely uses Turing completeness.

  Ethereum Virtual Machines have been successfully implemented in
  various programming languages including C++, Java, JavaScript, Python,
  Ruby, and many others.

  The EVM is essential to the Ethereum Protocol and is instrumental to
  the consensus engine of the Ethereum system. It allows anyone to
  execute code in a trustless ecosystem in which the outcome of an
  execution can be guaranteed and is fully deterministic (i.e.)
  executing smart contracts.

  \subsection{Non-Interactive Proofs Of Proof Of Work}

  Describe the rationale behind NIPoPoWs, what they provide

  \subsubsection{Prefix Proofs}

  Describe prefix proofs

  \subsubsection{Suffix Proofs}

  Describe suffix proofs

  \subsubsection{Infix Proofs}

  Describe infix proofs

  \subsection{Forks}

  Soft, hard and velvet fork

  \subsection{Difficulty}

  Describe constant and non-constant difficulty

  \pagebreak

  \section{Implementation}

  \subsection{Environment Set-Up}

  \subsubsection{Existing Environments}

  The first step towards starting the implementation is to set up a
  comfortable and adjustable environment. There are several environments
  one can use to build Solidity applications, most popular of which are
  Truffle(ref), Remix(ref) and Embark(ref). However, none of the
  aforementioned delivered the experience we needed in the scope of our
  project, due to the lack of speed and customization options. Hence, we
  created a custom environment to import, compile, deploy and test smart
  contracts.

  We used Python(ref) to build our environment, since it is a powerful
  and convenient programming language, and all of our dependencies had
  Python implementations available. We developed our environment in
  Linux(ref).

  \subsubsection{Dependencies}

  The components we used as building blocks are Web3(ref) which is a
  powerful library for interacting with Ethereum, the Solidity
  compiler(ref), and EthereumTester which is a set of tools for testing
  Ethereum-based applications. For the purpose of our project, a private
  blockchain running an Ethereum Virtual Machine (EVM) was deployed.
  This is a common practice for Ethereum developers since it greatly
  facilitates testing procedures. Our environment supports multiple
  EVMs, namely Geth(ref), Ganache(ref) and Py-EVM(ref).

  \subsubsection{Ethereum Virtual Machines}

  All aforementioned EVMs deliver an implementation that complies with
  the specifications as described at the Ethereum yellow paper(ref).
  However, different implementations provide unique attributes to the
  developer, each of which helped us to progress effortlessly during
  different stages of our implementation.

  Py-EVM is an evolving EVM which is created mainly for testing. The
  ease of access and use, the configuration freedom of its underlying
  test chain and its effectiveness for small sized data helped our first
  steps. However, as the input data size started to grow, the
  effectiveness of the tool rapidly fell(ref).

  Ganache is a popular EVM developed by the Truffle team. It’s speed and
  configuration freedom are its main advantages. However, its extreme
  memory requirement made it impossible to use when the sizes of the
  input were analogous to the Bitcoin blockchain size.

  Geth is another popular EVM which is created by the Ethereum team. It
  also supports heavy customization while its memory usage is very
  limited compared to Ganache, even for extensive inputs. It is,
  however, slower than Ganache.

  The set of configurations we used for each EVM can be found in our
  public repository(ref).

  TODO: insert figure of Py-EVM vs Ganache vs Geth

  \subsubsection{Gas Profiling}

  Another useful utility we used was solidity-gas-profiler(ref), a
  profiling utility by Yushih. This gave us great insights regarding the
  gas usage across contract’s functions, and, consequently, helped us
  target the functionalities that needed to be refined.

  TODO: insert figure of gas profiling

  \subsection{Model}

  As mentioned above, we used a previous verifier implementation(ref) as
  a basis for our implementation. Since we adopted common primitives, we
  used some of the tools Giorgos et al. used for functionalities such as
  constructing blockchains and proofs. For the purposes of our project,
  we needed to enhance the functionality of the existing tools in some
  cases. We are thankful to the writers for sharing their
  implementation. This greatly facilitated our work. Similar to Giorgos
  el al., we follow the steps listed below:

  \begin{enumerate}
  \item
    Construct a blockchain
  \item
    Construct a proof for an event in the blockchain
  \item
    Verify the proof
  \end{enumerate}

  In this subsection, we describe the model under which both
  implementations were deployed.

  \subsubsection{Blockchain}

  The tool that creates the blockchain was created by Andrew Miller, one
  of the writers of Non-Interactive Proofs of Proof of Work(ref) paper.
  The tool is using the Bitcoin library(ref) to construct a blockchain
  similar to Bitcoin’s. The interlink pointers are organised into a
  merkle tree and the index is determined by their level. For details
  regarding the level calculation, see section(ref). The merkle root of
  the interlink tree is a 32-bit value, and is included in the
  blockheader as an additional value. The new size of the block header
  is 112 bytes. In order to ensure security, it is important for the
  interlink root to be included in the block header, as it is part of
  the proof. Otherwise, attackers could attack the proofs by reordering
  or including stray blocks. Miners can easily verify that the merkle
  root is correct.

  TODO: figure of the blockchain

  \subsubsection{Superblock Levels}

  We assume that the difficulty target of mined blocks is constant. As
  discussed in section(ref), this is not the model of the Bitcoin
  blockchain. The definition of superblocks is changed to a simpler
  definition and the level is determined by the number of leading zeros
  of the block header hash. Although this change does not take into
  account the difficulty target, the scoring of proof of work does not
  generate security holes in the protocol.

  \subsubsection{Proof}

  The tool that creates proofs was also created by Andrew Miller. The
  prover receives the following inputs:

  \begin{itemize}
  \item
    A blockchain with interlinks
  \item
    The security parameter k
  \item
    The security parameter m
  \end{itemize}

  Security parameters k, m are part of the NIPoPoW model and are
  explained in section(ref).

  The prover’s output is a proof of proof of work that satisfies the
  above security parameters. The prover needed to be enhanced in order
  to create special test cases (section(ref)) and enable our optimized
  architecture (section(ref)).

  TODO: figure of proof

  \subsubsection{Verifier}

  The goal of the verifier is to accept valid proofs and discard invalid
  proofs. A proof is submitted in combination with a predicate. The
  proof is considered valid if it is constructively correct and the
  predicate is true for the chain described by the proof. The predicate
  can represent the existence of an event in the source blockchain, such
  as the occurrence of a transaction. In our case, the predicate
  indicates the existence of a block in the proof.

  The verifier functions in two phases: (a) submit phase and (b) contest
  phase. Each phase has different inputs and functionalities, and is
  performed by different entities.

  During the submit phase, an entity submits a proof and an event.
  During this phase, we assume that at least one honest full node is
  aware of the submission. This is also a part of the model of NIPoPoW,
  and is a logical assumption as explained in the paper.

  In order to perform a submission, one must provide a proof and a
  predicate. If a certain number of rounds passes without submission of
  contestations, the proof is considered valid and the predicate is
  considered true. The passing of rounds is indicated by the mining of
  new blocks atop of the block containing the submission.

  If the submitted proof is invalid (i.e. the predicate is not true for
  the honest chain), a contesting proof is submitted, invalidating the
  original proof and predicate. The contesting proof is considered
  better only if it encapsulates more proof of work than the existing
  proof, as described in the NIPoPoWs paper. In order to perform a
  submission, one must provide a consteting proof and the predicate that
  is claimed to be true by the originally submitted proof. If the
  contesting proof has better score, then the predicate is evaluated
  against the contesting proof.

  TODO: Add matrix or something else to show Honest Submit + No Constest
  -> Predicate = True Honest Submit + Adversary Contest -> Predicate =
  True Adversary Submit + Honest Contest -> Predicate = False Adversary
  Submit + No Contest -> Impossible

  \subsection{Previous Implementation}

  \subsection{Targeting vulnerabilities and costly functionalities}

  \begin{itemize}
  \item
    0. Knowledge that extensive gas usage is due to large storage
    allocation
  \item
    1. Make old contract compatible with the last version of solidity
    compiler
  \item
    2. Create tests for all functionalities
  \item
    3. Identify and fix vulnerabilities

    Gas was very high due to storage variables

    Contract is vulnerable to premining
  \item
    4. Profile contract gas usage
  \item
    5. Identify expensive operations
  \end{itemize}

  \subsection{Fixing vulnerabilities and restricting gas usage}

  \begin{itemize}

  \item
    Add verification of genesis
  \item
    Reconsider DAG and ancestors methodology and redesign submission and
    contest schema
  \item
    Submit doesn't need to save in the proof in storage. Contest can
    provide the existing proof during contesting.

  \item
    Use subset: P1\{:lca\} $>$ P2\{:lca\}, P1 is the existing, P2 is the
    contesting

    This prevents expensive storage for DAG and ancestors.

  \item
    Even the check of subset can be skipped. The contesting proof cannot
    benefit from pre-lca malformed proof. If Pa is valid, then we just
    need to check Pb[lca:]

  \item
    This is not vulnerable to DOS attacks

  \item
    Observe the network and contest with the appropriate proof if
    submitted is not correct.

  \end{itemize}

  \section{Results}

  \section{Conclusion}

  \section{Future Work}

\end{document}

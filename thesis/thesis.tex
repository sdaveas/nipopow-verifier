\documentclass{article}

\usepackage[utf8]{inputenc}

\title{A gas-efficient superlight Bitcoin client in Solidity}
\begin{document}

  \maketitle

  \begin{abstract}
    Place abstract here
  \end{abstract}

  \pagebreak

  \section{Introduction}

  \subsection{Motivation}

  Digital coins are peer-to-peer currencies based on applied
  cryptography for the validation of transactions. Most of them are
  based on blockchain(ref), a form of decentralized database. In this
  database, a public ledger is deployed, which is stored and updated by
  thousands of users in absence of supervision from public authorities.

  In 2008, Bitcoin(ref), the first ever successful decentralized digital
  coin, was invented by an unknown person or group of people using the
  name Satoshi Nakamoto. A year after, the bitcoin network started,
  quickly followed by several other digital coins, which in the
  cryptocurrency folklore are known as altcoins. Usually, altcoins are
  based on innovative features missing from the cryptocurrency market,
  and they are either accepted or rejected by the community. Popular
  altcoins are Ethereum(ref), which is the first to provide smart
  contracts, Ripple(ref) which provides real-time payment settlements
  and Litecoin(ref) which enables near-zero cost payments.

  Over the last decade, cryptocurrencies gained attention from the
  public as an increased number of users are accepting and adapting to
  decentralized transactions. Specifically, in 2017, the popularity of
  cryptocurrencies rapidly grew, resulting in massive capitalisation and
  creation of tokens. During this period, some of the issues that
  blockchain technology faces were displayed. One of these issues is
  blockchain interoperability, the property of distinct blockchains to
  interact efficiently with each other. Despite its great importance,
  this field has not been addressed until recently. To date,
  cryptocurrencies are lacking a commonly accepted protocol that enables
  distributed interoperability. Such a protocol would be very useful to
  blockchain technology, since it would allow users to variously utilize
  features of different blockchains. For example, one can store their
  funds at Bitcoins, and convert them to Ether to make a payment,
  benefiting from lower transaction fees.

  \bigbreak A crosschain protocol would enable two main operations:
  \begin{itemize}
  \item
    Crosschain trading: An entity that has deposits in a blockchain A,
    makes a payment to an entity at a blockchain B.
  \item
    Crosschain fund transfer: Entity transfers funds from blockchain A
    to blockchain B. After this operation, the funds no longer exist at
    blockchain A. The entity can decide to return any portion of the
    original amount to the blockchain of origin.
  \end{itemize}

  Currently, this operation is only available to the users via third
  party applications, such as multi-currency wallets. This treatment
  certainly opposes the nature of blockchain, which is a decentralized
  construction. This motivated us to create a solution that provides
  cheap, trust-less crosschain operations.

  \subsection{Previous Work}

  In this paper, we focus on recent research in the area of crosschains.
  In particular, we make use of Non-Interactive Proofs of Proof of Work
  (NIPoPoWs)(ref), which enables the compression of a chain to its
  poly-logarothmic size. NIPoPoWs is the main building block of our
  solution in order to prove to blockchain A that an event happened in
  blockchain B.

  We are based on the work done by Giorgos Christoglou et al.(ref),
  which was the first ever implementation of crosschain events
  verification, and was used as a starting point for our solution. The
  work of Giorgos et al. focuses on verifying Bitcoin events from the
  Ethereum blockchain. In order to provide this functionality, a NIPoPoW
  verifier was developed in Solidity(ref), one of the programming
  languages of Ethereum blockchain. This solution, however, is
  impossible to be applied in a real blockchain due to extensive gas
  usage and severe security issues.

  \subsection{Our Contributions}

  A series of keen observations, the application of gas-efficient
  practices, and the utilization of modern Solidity features, led us to
  implement a new verifier architecture. This allowed us to repair
  previous vulnerabilities and enable crosschain operations by providing
  a secure, superlight Bitcoin client that can be deployed on the real
  blockchain. \bigbreak Our contribution is the creation of a Bitcoin
  client in Solidity that meets with the following criteria:
  \begin{itemize}
  \item
    Security: Is secure against any adversarial attack.
  \item
    Trustless: Does not have dependencies at any third-party
    applications.
  \item
    Applicability: Is applicable to the real blockchain. That is, data
    derived from the full-sized Bitcoin blockchain are successfully
    accepted and processed without exceeding the build-in constraints of
    the Ethereum blockchain (i.e. block gas limit. call data limit etc).
  \item
    Cheap: Is cheaper than the current state of the art technologies.
    This would make trustless crosschain transactions more popular and
    affordable.
  \end{itemize}

  \pagebreak

  \section{Background}

  Relevant technologies

  \subsection{Primitives}

  Describe primitives

  \subsection{Bitcoin}

  Describe Bitcoin blockchain

  \subsection{Ethereum}

  Describe Ethereum blockchain

  \subsubsection{Solidity}

  Describe the use of solidity language

  \subsubsection{Smark contracts}

  Describe the use of smart contracts

  \subsubsection{Ethereum Virtual Machine}

  The Ethereum Virtual Machine (EVM) is a sandboxed virtual stack
  embedded within each full Ethereum node, responsible for executing
  contract bytecode. Contracts are typically written in higher level
  languages, like Solidity, then compiled to EVM bytecode.

  This means that the machine code is completely isolated from the
  network, filesystem or any processes of the host computer. Every node
  in the Ethereum network runs an EVM instance which allows them to
  agree on executing the same instructions. The EVM is Turing complete,
  which refers to a system capable of performing any logical step of a
  computational function. JavaScript, the programming language which
  powers the worldwide web, widely uses Turing completeness.

  Ethereum Virtual Machines have been successfully implemented in
  various programming languages including C++, Java, JavaScript, Python,
  Ruby, and many others.

  The EVM is essential to the Ethereum Protocol and is instrumental to
  the consensus engine of the Ethereum system. It allows anyone to
  execute code in a trustless ecosystem in which the outcome of an
  execution can be guaranteed and is fully deterministic (i.e.)
  executing smart contracts.

  \subsection{Non-Interactive Proofs Of Proof Of Work}

  Describe the rationale behind NIPoPoWs, what they provide

  \subsubsection{Prefix Proofs}

  Describe prefix proofs

  \subsubsection{Suffix Proofs}

  Describe suffix proofs

  \subsubsection{Infix Proofs}

  Describe infix proofs

  \subsection{Forks}

  Soft, hard and velvet fork

  \subsection{Difficulty}

  Describe constant and non-constant difficulty

  \pagebreak

  \section{Implementation}

  \subsection{Environment Set-Up}

  \subsubsection{Existing Environments}

  The first step towards starting the implementation is to set up a
  comfortable and adjustable environment. There are several environments
  one can use to build Solidity applications, most popular of which are
  Truffle(ref), Remix(ref) and Embark(ref). However, none of the
  aforementioned delivered the experience we needed in the scope of our
  project, due to the lack of speed and customization options. Hence, we
  created a custom environment to import, compile, deploy and test smart
  contracts.

  We used Python(ref) to build our environment, since it is a powerful
  and convenient programming language, and all of our dependencies had
  Python implementations available. We developed our environment in
  Linux(ref).

  \subsubsection{Dependencies}

  The components we used as building blocks are Web3(ref) which is a
  powerful library for interacting with Ethereum, the Solidity
  compiler(ref), and EthereumTester which is a set of tools for testing
  Ethereum-based applications. For the purpose of our project, a private
  blockchain running an Ethereum Virtual Machine (EVM) was deployed.
  This is a common practice for Ethereum developers since it greatly
  facilitates testing procedures. Our environment supports multiple
  EVMs, namely Geth(ref), Ganache(ref) and Py-EVM(ref).

  \subsubsection{EVMs}

  All aforementioned EVMs deliver an implementation that complies with
  the specifications as described at the Ethereum yellow paper(ref).
  However, different implementations provide unique attributes to the
  developer, each of which helped us to progress effortlessly at
  different states of our implementation.

  Py-EVM is an evolving EVM which is created mainly for testing. The
  ease of access and use, the configuration freedom of its underlying
  test chain and its effectiveness for small sized data helped our first
  steps. However, as the input data size started to grow, the
  effectiveness of the tool rapidly fell.

  Ganache is a popular EVM developed by the Truffle team. It’s speed and
  configuration freedom are its main advantages. However, its extreme
  memory requirements made it impossible to use when the sizes of the
  input were analogous to the Bitcoin blockchain size.

  Geth is another popular EVM which is created by the Ethereum team. It
  also supports heavy customization while its memory usage is very
  limited compared to Ganache, even for extensive input. It is, however,
  slower than the Ganache.

  The set of configurations we used for each EVM can be found in our
  public repository(ref).

  TODO: insert figure of Py-EVM vs Ganache vs Geth

  \subsubsection{Gas Profiling}

  Another useful utility we used was solidity-gas-profiler(ref), a
  profiling utility by Yushih. This gave us great insights regarding the
  gas usage across contract’s functions, and, consequently, helped us
  target the functionalities that needed to be refined.

  TODO: insert figure of gas profiling

  \subsection{Previous Implementation}

  \subsection{Targeting vulnerabilities and costly functionalities}

  \begin{itemize}
  \item
    0. Knowledge that extensive gas usage is due to large storage
    allocation
  \item
    1. Make old contract compatible with the last version of solidity
    compiler
  \item
    2. Create tests for all functionalities
  \item
    3. Identify and fix vulnerabilities

    Gas was very high due to storage variables

    Contract is vulnerable to premining
  \item
    4. Profile contract gas usage
  \item
    5. Identify expensive operations
  \end{itemize}

  \subsection{Fixing vulnerabilities and restricting gas usage}

  \begin{itemize}

  \item
    Add verification of genesis
  \item
    Reconsider DAG and ancestors methodology and redesign submission and
    contest schema
  \item
    Submit doesn't need to save in the proof in storage. Contest can
    provide the existing proof during contesting.

  \item
    Use subset: P1\{:lca\} $>$ P2\{:lca\}, P1 is the existing, P2 is the
    contesting

    This prevents expensive storage for DAG and ancestors.

  \item
    Even the check of subset can be skipped. The contesting proof cannot
    benefit from pre-lca malformed proof. If Pa is valid, then we just
    need to check Pb[lca:]

  \item
    This is not vulnerable to DOS attacks

  \item
    Observe the network and contest with the appropriate proof if
    submitted is not correct.

  \end{itemize}

  \section{Results}

  \section{Conclusion}

  \section{Future Work}

\end{document}
